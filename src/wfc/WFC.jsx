import Frame from "./Frame";
import {getRdmInt} from "../utilities";

export default class {

    // todo : switching to a one-d array may be faster
    constructor(width, height, depth, tiles, failSafeTile) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.size = width*height*depth;
        this.grid = [...Array(width*height*depth)].map(() => new Frame(tiles, failSafeTile));
        this.fillFramesNeighbours();

        this.allCollapsed = false;
    }

    getCoordinates = (i) => [
        Math.floor(i/this.height/this.depth),
        Math.floor((i%(this.height*this.depth))/this.height),
        i % this.depth
    ];

    fillFramesNeighbours = () => this.grid.forEach((frame, i) => {
        const [x,y,z] = this.getCoordinates(i);
        if (x > 0) frame.neiMinusX = this.grid[i-this.height*this.depth];
        if (y > 0) frame.neiMinusY = this.grid[i-this.depth];
        if (z > 0) frame.neiMinusZ = this.grid[i-1];
        if (x < this.width - 1) frame.neiPlusX = this.grid[i+this.height*this.depth];
        if (y < this.height - 1) frame.neiPlusY = this.grid[i+this.depth];
        if (z < this.depth - 1) frame.neiPlusZ = this.grid[i+1];
    });


    /**
     * choose a random frame not collapsed in the grid
     * currently unoptimized (generated by chatgpt)
     * */
    chooseRandomFrame = () => {
        if(this.allCollapsed) throw new Error('chooseRandomFrame: cannot choose a frame if all of them are collapsed');

        let eligibleFrames = [];

        for (let i = 0; i < this.size; i++) {
            const frame = this.grid[i];
            if (!frame.collapsed){
                eligibleFrames.push(frame);
            }
        }

        if(eligibleFrames.length === 0) {
            this.allCollapsed = true;
            return;
        }

        let minTilesCount = Infinity;

        eligibleFrames.forEach((frame) => {
            const tilesCount = frame.tiles.length;
            if (tilesCount < minTilesCount) {
                minTilesCount = tilesCount;
            }
        });

        eligibleFrames = eligibleFrames.filter(
            (frame) => frame.tiles.length === minTilesCount
        );

        const randomIndex = getRdmInt(0, eligibleFrames.length);
        return eligibleFrames[randomIndex];
    }

    run = () => {
        while (!this.allCollapsed){
            const frame = this.chooseRandomFrame();
            if (this.allCollapsed) break;
            frame.collapse();
            frame.forEachNeighbours((nei, dir) =>
                nei.propagate(frame.tile["ok"+dir])
            );
        }
    }

}