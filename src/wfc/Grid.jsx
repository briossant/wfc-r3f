import Frame from "./Frame";
import {getRdmInt} from "../utilities";

export default class {

    // todo : switching to a one-d array may be faster
    constructor(width, height, depth, tiles) {
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.grid = [...Array(width)].map(() =>
            [...Array(width)].map(() =>
                [...Array(depth)].map(() => new Frame(tiles))
            ));
        this.fillFramesNeighbours();

        this.allCollapsed = false;
    }

    fillFramesNeighbours = () => this.grid.forEach((row, x) => {
        row.forEach((line,y) => {
            line.forEach((frame,z) =>{
                if(x>0) frame.neiMinusX = this.grid[x-1][y][z];
                if(y>0) frame.neiMinusY = this.grid[x][y-1][z];
                if(z>0) frame.neiMinusZ = this.grid[x][y][z-1];
                if(x<this.width-1) frame.neiPlusX = this.grid[x+1][y][z];
                if(y<this.height-1) frame.neiPlusY = this.grid[x][y+1][z];
                if(z<this.depth-1) frame.neiPlusZ = this.grid[x][y][z+1];
            });
        });
    });


    /**
     * choose a random frame not collapsed in the grid
     * currently unoptimized (generated by chatgpt)
     * */
    chooseRandomFrame = () => {
        if(this.allCollapsed) throw new Error('chooseRandomFrame: cannot choose a frame if all of them are collapsed');

        let eligibleFrames = [];

        for (let x = 0; x < this.width; x++) {
            for (let y = 0; y < this.width; y++) {
                for (let z = 0; z < this.depth; z++) {
                    const frame = this.grid[x][y][z];
                    if (!frame.collapsed) {
                        eligibleFrames.push(frame);
                    }
                }
            }
        }

        if(eligibleFrames.length === 0) {
            this.allCollapsed = true;
            return;
        }

        let minTilesCount = Infinity;

        eligibleFrames.forEach((frame) => {
            const tilesCount = frame.tiles.length;
            if (tilesCount < minTilesCount) {
                minTilesCount = tilesCount;
            }
        });

        eligibleFrames = eligibleFrames.filter(
            (frame) => frame.tiles.length === minTilesCount
        );

        const randomIndex = getRdmInt(0, eligibleFrames.length);
        return eligibleFrames[randomIndex];
    }

    run = () => {
        while (!this.allCollapsed){
            const frame = this.chooseRandomFrame();
            if (this.allCollapsed) break;
            frame.collapse();
            frame.forEachNeighbours((nei, dir) =>
                nei.propagate(frame.tile["ok"+dir])
            );
        }
    }

}